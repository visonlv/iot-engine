// Code generated by protoc-gen-vkit.
// versions:
// - protoc-gen-vkit v1.0.0

package handler

import (
	context "context"
	"fmt"
	"net/http"
	"time"

	"github.com/visonlv/iot-engine/auth/app"
	pb "github.com/visonlv/iot-engine/auth/proto"
	"github.com/visonlv/iot-engine/auth/rediskey"
	"github.com/visonlv/iot-engine/auth/utils"

	"github.com/visonlv/iot-engine/auth/model"

	"github.com/visonlv/iot-engine/auth/handler/auth"
	"github.com/visonlv/iot-engine/auth/handler/convert"
	"github.com/visonlv/iot-engine/auth/handler/verification"

	"github.com/visonlv/iot-engine/auth/handler/user"

	"github.com/visonlv/go-vkit/errorsx"
	"github.com/visonlv/go-vkit/logger"
	"gorm.io/gorm"
)

type AuthService struct {
}

func (the *AuthService) GenToken(ctx context.Context, req *pb.GenTokenReq, resp *pb.GenTokenResp) error {
	if req.Expiry == 0 {
		req.Expiry = int64(rediskey.TokenKey.Expire)
	}
	roles := []string{req.RoleCode}
	if req.RoleCode == "" {
		codes, err := user.RolesByUserAndAppCode(req.UserId, req.AppCode)
		if err != nil {
			resp.Code = errorsx.FAIL.Code
			resp.Msg = "获取该用户角色失败:" + err.Error()
			return nil
		}
		roles = codes
	}
	token := utils.GenToken(&utils.Account{Id: req.UserId, Roles: roles, AppCode: req.AppCode}, time.Duration(req.Expiry*int64(time.Second)))
	err := auth.AddToken(req.AppCode, req.UserId, req.RoleCode, token)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "添加Token失败:" + err.Error()
		return nil
	}
	resp.Code = errorsx.OK.Code
	resp.Token = token
	return nil
}

func (the *AuthService) Inspect(ctx context.Context, req *pb.InspectReq, resp *pb.InspectResp) error {
	authClaim, err := utils.ParseToken(req.Token)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "请求令牌失效"
		return nil
	}

	err = auth.UserTokenExist(req.Token)
	if err != nil {
		resp.IsExist = false
	} else {
		resp.IsExist = true
	}
	user, err := model.UserGetFromCache(nil, authClaim.Id)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}
	resp.User, err = convert.UserToUserPb(user, authClaim.AppCode)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}
	resp.Code = errorsx.OK.Code
	resp.AppCode = authClaim.AppCode
	return nil
}

func (the *AuthService) RefreshToken(ctx context.Context, req *pb.RefreshTokenReq, resp *pb.RefreshTokenResp) error {
	authClaim, err := utils.ParseToken(req.Token)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}
	rolecode := authClaim.Roles[0]
	if len(authClaim.Roles) > 1 {
		rolecode = ""
	}
	err = auth.UserTokenExist(req.Token)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}

	token := utils.GenToken(&utils.Account{Id: authClaim.Id, Roles: authClaim.Roles, AppCode: authClaim.AppCode}, time.Duration(authClaim.ExpiresAt*int64(time.Second)))
	err = auth.AddToken(authClaim.AppCode, authClaim.Id, rolecode, token)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "添加Token失败:" + err.Error()
		return nil
	}
	resp.Code = errorsx.OK.Code
	resp.Token = token
	return nil
}

func (the *AuthService) APIPermissions(ctx context.Context, req *pb.APIPermissionsReq, resp *pb.APIPermissionsResp) error {
	//判断是否在白名单中
	if auth.AuthObj.IsWhite(req.Api) {
		resp.Code = errorsx.OK.Code
		resp.IsWhite = true
		return nil
	}
	if req.Token == "" {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "没有请求令牌，请求失败!"
		return nil
	}
	authClaim, err := utils.ParseToken(req.Token)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "请求令牌失效"
		resp.HttpStatus = http.StatusUnauthorized
		logger.Errorf("请求令牌失效 %s,令牌：%s", err.Error(), req.Token)
		return nil
	}
	resp.AppCode = authClaim.AppCode
	resp.UserId = authClaim.Id
	resp.RoleCodes = authClaim.Roles
	err = auth.UserTokenExist(req.Token)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		resp.HttpStatus = http.StatusUnauthorized
		return nil
	}
	enable := auth.AuthObj.IsPemission(authClaim.AppCode, authClaim.Roles, req.Api)
	resp.Code = errorsx.OK.Code
	resp.Enable = enable

	resp.HttpStatus = http.StatusOK
	if !enable {
		resp.HttpStatus = http.StatusForbidden
	}
	return nil
}

func (the *AuthService) DelToken(ctx context.Context, req *pb.DelTokenReq, resp *pb.DelTokenResp) error {
	if req.Token != "" {
		auth.DeleteToken(req.Token)
	}
	resp.Code = errorsx.OK.Code
	return nil
}

func (the *AuthService) Login(ctx context.Context, req *pb.LoginReq, resp *pb.LoginResp) error {
	// 获取用户信息
	userModel, err := model.UserGetByAccount(nil, req.Account)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		if err == gorm.ErrRecordNotFound {
			resp.Msg = "用户不存在"
		} else {
			resp.Msg = err.Error()
		}
		return nil
	}
	// 校验密码
	if user.EncodePassword(req.Password) != userModel.Password {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "密码错误"
		return nil
	}

	roles := make([]string, 0)
	// 获取对应角色
	list, err := model.RoleListByUserId(nil, userModel.Id)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}
	if len(list) == 0 {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "登录失败：该用户未分配角色"
		return nil
	}
	hasRole := false
	for _, v := range list {
		if len(req.RoleCode) != 0 {
			if v.Code == req.RoleCode {
				hasRole = true
				break
			}
		} else {
			roles = append(roles, v.Code)
		}
	}
	if len(req.RoleCode) != 0 {
		if !hasRole {
			resp.Code = errorsx.FAIL.Code
			resp.Msg = "登录失败：该账号无权登录当前应用"
			return nil
		}
		roles = append(roles, req.RoleCode)

	}
	hasLogin := false
	for _, rr := range roles {
		hasLogin = auth.AuthObj.IsAllowLogin(req.AppCode, rr)
		if hasLogin {
			break
		}
	}
	if !hasLogin {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "登录失败：用户无权访问当前应用"
		return nil
	}

	//生成token
	t := &utils.Account{
		Id:       userModel.Id,
		Roles:    roles,
		Metadata: "{}",
		AppCode:  req.AppCode,
	}
	expire := time.Duration(req.Expiry)
	if expire == 0 {
		expire = rediskey.TokenKey.Expire
	}
	tt := utils.GenToken(t, expire*time.Second)
	err = auth.AddToken(req.AppCode, userModel.Id, req.RoleCode, tt)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "添加Token失败:" + err.Error()
		return nil
	}
	resp.Token = tt
	resp.RoleCodes = roles
	resp.UserId = userModel.Id

	return nil
}

func (the *AuthService) LoginByPhone(ctx context.Context, req *pb.LoginByPhoneReq, resp *pb.LoginByPhoneResp) error {
	// 获取用户信息
	userModel, err := model.UserGetByPhone(nil, req.Phone)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		if err == gorm.ErrRecordNotFound {
			resp.Msg = "手机号未注册"
		} else {
			resp.Msg = err.Error()
		}
		return nil
	}
	// 校验验证码
	rKey := req.AppCode + "_" + req.Phone
	code, err := app.Redis.GetString(rediskey.PhoneMessageCodeKey, rKey)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "验证码已经过期"
		logger.Errorf("验证码已经过期 %s", err.Error())
		return nil
	}
	if code != req.VerifyCode {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "验证码错误"
		return nil
	}
	app.Redis.Del(rediskey.PhoneMessageCodeKey, rKey)
	// //todo 省略获取短信验证码的逻辑，目前固定6个0
	// if req.VerifyCode != "000000" {
	// 	resp.Code = errorsx.FAIL.Code
	// 	resp.Msg = "验证码错误"
	// 	return nil
	// }
	roles := make([]string, 0)
	// 获取对应角色
	list, err := model.RoleListByUserId(nil, userModel.Id)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}
	if len(list) == 0 {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "登录失败：该用户未分配角色"
		return nil
	}
	hasRole := false
	for _, v := range list {
		if len(req.RoleCode) != 0 {
			if v.Code == req.RoleCode {
				hasRole = true
				break
			}
		} else {
			roles = append(roles, v.Code)
		}

	}
	//指定角色登录
	if len(req.RoleCode) != 0 {
		if !hasRole {
			resp.Code = errorsx.FAIL.Code
			resp.Msg = "登录失败：该账号无权登录当前应用"
			return nil
		}
		roles = append(roles, req.RoleCode)
	}
	hasLogin := false
	for _, rr := range roles {
		hasLogin = auth.AuthObj.IsAllowLogin(req.AppCode, rr)
		if hasLogin {
			break
		}
	}
	if !hasLogin {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "登录失败：用户无权访问当前应用"
		return nil
	}
	//生成token
	t := &utils.Account{
		Id:       userModel.Id,
		Roles:    roles,
		Metadata: "{}",
		AppCode:  req.AppCode,
	}
	expire := time.Duration(req.Expiry)
	if expire == 0 {
		expire = rediskey.TokenKey.Expire
	}
	tt := utils.GenToken(t, expire*time.Second)
	err = auth.AddToken(req.AppCode, userModel.Id, roles[0], tt)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "添加Token失败:" + err.Error()
		return nil
	}
	resp.Token = tt
	resp.RoleCodes = roles
	resp.UserId = userModel.Id
	resp.RoleCodes = roles
	return nil
}

func (the *AuthService) LoginByEmail(ctx context.Context, req *pb.LoginByEmailReq, resp *pb.LoginByEmailResp) error {
	// 获取用户信息
	userModel, err := model.UserGetByEmail(nil, req.Email)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		if err == gorm.ErrRecordNotFound {
			resp.Msg = "邮箱不存在"
		} else {
			resp.Msg = err.Error()
		}
		return nil
	}
	// 校验密码
	if user.EncodePassword(req.Password) != userModel.Password {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "密码错误"
		return nil
	}

	// 获取对应角色
	list, err := model.RoleListByUserId(nil, userModel.Id)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}
	if len(list) == 0 {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "登录失败：该用户未分配角色"
		return nil
	}
	roles := make([]string, 0)
	hasRole := false
	for _, v := range list {
		if len(req.RoleCode) != 0 {
			if v.Code == req.RoleCode {
				hasRole = true
				break
			}
		} else {
			roles = append(roles, v.Code)
		}

	}
	//指定角色登录
	if len(req.RoleCode) != 0 {
		if !hasRole {
			resp.Code = errorsx.FAIL.Code
			resp.Msg = "登录失败：该账号无权登录当前应用"
			return nil
		}
		roles = append(roles, req.RoleCode)
	}
	hasLogin := false
	for _, rr := range roles {
		hasLogin = auth.AuthObj.IsAllowLogin(req.AppCode, rr)
		if hasLogin {
			break
		}
	}
	if !hasLogin {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "登录失败：用户无权访问当前应用"
		return nil
	}
	//生成token
	t := &utils.Account{
		Id:       userModel.Id,
		Roles:    roles,
		Metadata: "{}",
		AppCode:  req.AppCode,
	}
	expire := time.Duration(req.Expiry)
	if expire == 0 {
		expire = rediskey.TokenKey.Expire
	}
	tt := utils.GenToken(t, expire*time.Second)
	err = auth.AddToken(req.AppCode, userModel.Id, roles[0], tt)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "添加Token失败:" + err.Error()
		return nil
	}
	resp.Token = tt
	resp.RoleCodes = roles
	resp.UserId = userModel.Id
	return nil
}

func (the *AuthService) VerificationCode(ctx context.Context, req *pb.VerificationCodeReq, resp *pb.Response) error {
	msg := ""
	var err error
	switch req.Method {
	case model.VerificationMethodPhone:
		//todo 省略手机验证码发送
		msg = "手机号"
		err = verification.VerificationPhone(req.AppCode, req.Object)
	case model.VerificationMethodPEmail:
		msg = "邮箱"
		err = verification.VerificationEmail(req.Object)
	default:
		err = fmt.Errorf("请选择指定方式发送验证码")
	}
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}
	resp.Code = errorsx.OK.Code
	resp.Msg = "验证码已发送到指定" + msg
	return nil
}

func (the *AuthService) Logout(ctx context.Context, req *pb.LogoutReq, resp *pb.LogoutResp) error {
	token := utils.GetValueFromContext(ctx, "AuthToken")
	if len(token) == 0 {
		resp.Code = errorsx.OK.Code
		resp.Msg = "AuthToken为空"
		return nil
	}
	auth.DeleteToken(token)
	resp.Code = errorsx.OK.Code
	return nil
}

func (the *AuthService) ForgetPassword(ctx context.Context, req *pb.ForgetPasswordReq, resp *pb.ForgetPasswordResp) error {
	m, err := model.UserGetByEmail(nil, req.Email)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		if err == gorm.ErrRecordNotFound {
			resp.Msg = "邮箱不存在"
		} else {
			resp.Msg = "获取邮箱失败"
		}
		return nil
	}

	code, err := app.Redis.GetString(rediskey.VerificationCodeKey, req.Email)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "验证码已经过期"
		return nil
	}

	if code != req.VerificationCode {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "验证码错误"
		return nil
	}

	m.Password = user.EncodePassword(req.Password)
	_, err = model.UserUpdate(nil, m)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = fmt.Sprintf("用户更新失败:%s", err.Error())
		return nil
	}
	return nil
}

func (the *AuthService) VerifyPassword(ctx context.Context, req *pb.VerifyPasswordReq, resp *pb.VerifyPasswordResp) error {
	u, err := model.UserGetFromCache(nil, req.UserId)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = fmt.Sprintf("获取用户信息失败:%s", err.Error())
		return nil
	}
	newPw := user.EncodePassword(req.Password)
	if newPw != u.Password {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "密码验证失败"
		return nil
	}
	resp.Code = errorsx.OK.Code
	resp.Msg = "密码验证成功"
	return nil
}
