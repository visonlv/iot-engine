// Code generated by protoc-gen-vkit.
// versions:
// - protoc-gen-vkit v1.0.0

package handler

import (
	context "context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/spf13/cast"
	"github.com/visonlv/go-vkit/errorsx"
	"github.com/visonlv/go-vkit/logger"
	"github.com/visonlv/go-vkit/utilsx"
	"github.com/visonlv/iot-engine/common/client"
	"github.com/visonlv/iot-engine/common/define"
	"github.com/visonlv/iot-engine/common/utils"
	"github.com/visonlv/iot-engine/shadow/app"
	"github.com/visonlv/iot-engine/shadow/handler/forwarding"
	"github.com/visonlv/iot-engine/shadow/model"
	pb "github.com/visonlv/iot-engine/shadow/proto"
)

type ForwardingService struct {
}

func (the *ForwardingService) Properties(ctx context.Context, req *pb.ForwardingPropertiesReq, resp *pb.ForwardingPropertiesResp) error {
	if len(req.Pks) > 0 && len(req.Sns) > 0 {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "不可同时指定产品标识跟设备标识"
		return nil
	}

	var codeMap map[string]string
	if req.Codes != nil && len(req.Codes) > 0 {
		codeMap = map[string]string{}
		for _, v := range req.Codes {
			codeMap[v] = v
		}
	}

	// 获取内存中的属性
	list, err := forwarding.GetProperties(req)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = fmt.Sprintf("内存获取属性错误:%s", err.Error())
		return nil
	}
	hitCode := false

	// 产品过滤 或者整个分组过滤
	if len(req.Pks) > 0 || (len(req.Pks) == 0 && len(req.Sns) == 0) {
		if req.WithDefault {
			resp.Code = errorsx.FAIL.Code
			resp.Msg = "默认属性必须指定设备"
			return nil
		}
		memMap := make(map[string]*pb.ForwardingProperty)
		for _, v := range list {
			memMap[v.Sn] = v
		}

		var pks []string = nil
		if len(req.Pks) > 0 {
			pks = req.Pks
		}
		dbList, err := model.ShadowListBetweenGroupAndPk(nil, pks, app.Cfg.Group.Start, app.Cfg.Group.End)
		if err != nil {
			resp.Code = errorsx.FAIL.Code
			resp.Msg = fmt.Sprintf("数据库获取列表错误:%s", err.Error())
			return nil
		}

		lastList := make([]*pb.ForwardingProperty, 0)
		for _, v := range dbList {
			if v2, ok := memMap[v.Sn]; ok {
				lastList = append(lastList, v2)
			} else {
				s := &define.Shadow{}
				err := json.Unmarshal([]byte(v.Shadow), s)
				if err != nil {
					resp.Code = errorsx.FAIL.Code
					resp.Msg = fmt.Sprintf("影子数据错误:%s", err.Error())
					return nil
				}

				newPropertyMap := make(map[string]*pb.ForwardingPropertyItem, 0)
				for k, v := range s.Properties {
					hitCode = false
					if codeMap == nil {
						hitCode = true
					} else if _, ok := codeMap[k]; ok {
						hitCode = true
					}
					if hitCode {
						newStr, err := define.PropertyCurrentValurAsString(v.Current.Value)
						if err != nil {
							resp.Code = errorsx.FAIL.Code
							resp.Msg = fmt.Sprintf("影子属性格式化错误:%s", err.Error())
							return nil
						}
						newPropertyMap[k] = &pb.ForwardingPropertyItem{
							Value:      newStr,
							UpdateTime: v.Current.UpdatedTime,
						}
					}
				}
				lastList = append(lastList, &pb.ForwardingProperty{
					Pk:          v.Pk,
					Sn:          v.Sn,
					PropertyMap: newPropertyMap,
				})
			}
		}
		resp.List = lastList
		return nil
	}

	// 设备方式过滤
	if len(req.Sns) > 0 {
		//去除内存获取的属性
		memMap := make(map[string]*pb.ForwardingProperty)
		for _, v := range list {
			memMap[v.Sn] = v
		}
		newSns := make([]string, 0)
		for _, v := range req.Sns {
			if _, ok := memMap[v]; !ok {
				newSns = append(newSns, v)
			}
		}

		dbList := make([]*model.ShadowModel, 0)
		if len(req.Sns) != len(list) {
			dbList, err = model.ShadowListInSn(nil, newSns)
			if err != nil {
				resp.Code = errorsx.FAIL.Code
				resp.Msg = fmt.Sprintf("数据库获取列表错误:%s", err.Error())
				return nil
			}

			if len(dbList) != len(newSns) {
				resp.Code = errorsx.FAIL.Code
				resp.Msg = fmt.Sprintf("设备长度不一致:结果长度:%d 入参长度:%d", len(dbList), len(newSns))
				return nil
			}
		}
		for _, v := range dbList {
			s := &define.Shadow{}
			err := json.Unmarshal([]byte(v.Shadow), s)
			if err != nil {
				resp.Code = errorsx.FAIL.Code
				resp.Msg = fmt.Sprintf("影子数据错误:%s", err.Error())
				return nil
			}

			newPropertyMap := make(map[string]*pb.ForwardingPropertyItem, 0)
			for k, v := range s.Properties {
				hitCode = false
				if len(codeMap) == 0 {
					hitCode = true
				} else if _, ok := codeMap[k]; ok {
					hitCode = true
				}
				if !hitCode {
					continue
				}
				newStr, err := define.PropertyCurrentValurAsString(v.Current.Value)
				if err != nil {
					resp.Code = errorsx.FAIL.Code
					resp.Msg = fmt.Sprintf("影子属性格式化错误:%s", err.Error())
					return nil
				}
				newPropertyMap[k] = &pb.ForwardingPropertyItem{
					Value:      newStr,
					UpdateTime: v.Current.UpdatedTime,
				}
			}
			list = append(list, &pb.ForwardingProperty{
				Pk:          v.Pk,
				Sn:          v.Sn,
				PropertyMap: newPropertyMap,
			})
		}

		// 统一加默认值
		if req.WithDefault {
			// 获取所有产品
			pkMap := make(map[string]string)
			pks := make([]string, 0)
			for _, v := range list {
				if _, ok := pkMap[v.Pk]; !ok {
					pkMap[v.Pk] = v.Pk
					pks = append(pks, v.Pk)
				}
			}

			ps, err := forwarding.GetProductByPks(pks)
			if err != nil {
				resp.Code = errorsx.FAIL.Code
				resp.Msg = fmt.Sprintf("获取产品列表失败:%s", err.Error())
				return nil
			}

			for _, v := range list {
				p := ps[v.Pk]
				for code, _ := range codeMap {
					if _, ok := v.PropertyMap[code]; !ok {
						def, ok1 := p.ThingInfo.PropertyMap[code]
						if !ok1 {
							resp.Code = errorsx.FAIL.Code
							resp.Msg = fmt.Sprintf("产品:%s 属性%s 物模型没有定义", v.Pk, code)
							return nil
						}
						vl, err := define.GetPropertyDefaulValue(def)
						if err != nil {
							resp.Code = errorsx.FAIL.Code
							resp.Msg = fmt.Sprintf("获取默认值失败:%s", err.Error())
							return nil
						}
						v.PropertyMap[code] = &pb.ForwardingPropertyItem{
							Value:      vl,
							UpdateTime: 0,
						}
					}
				}
			}
		}

		resp.List = list
		return nil
	}

	resp.Code = errorsx.FAIL.Code
	resp.Msg = "参数错误"
	return nil
}

func (the *ForwardingService) Service(ctx context.Context, req *pb.ForwardingServiceReq, resp *pb.ForwardingServiceResp) error {
	msg, err := forwarding.CommonSendMsg(ctx, &forwarding.SendMsgReq{
		Sn:        req.Sn,
		ContextId: req.ContextId,
		Code:      req.Code,
		Payload:   []byte(req.Payload),
		MsgType:   "service",
		Timeout:   req.Timeout,
	})
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}

	resp.Code = msg.Code
	resp.Msg = msg.Msg
	if msg.M != nil {
		resp.M = msg.M
	}
	return nil
}

func (the *ForwardingService) SetProperty(ctx context.Context, req *pb.ForwardingSetPropertyReq, resp *pb.ForwardingSetPropertyResp) error {
	if define.IsSysPropertyCode(req.Code) {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = "系统属性不可操作"
		return nil
	}
	msg, err := forwarding.CommonSendMsg(ctx, &forwarding.SendMsgReq{
		Sn:        req.Sn,
		ContextId: req.ContextId,
		Code:      req.Code,
		Payload:   []byte(req.Payload),
		MsgType:   "property",
		Timeout:   req.Timeout,
	})
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}

	resp.Code = msg.Code
	resp.Msg = msg.Msg
	if msg.M != nil {
		resp.M = msg.M
	}
	return nil
}

func (the *ForwardingService) SetProperties(ctx context.Context, req *pb.ForwardingSetPropertiesReq, resp *pb.ForwardingSetPropertiesResp) error {
	code := define.MsgCodePropertyBatch
	msg, err := forwarding.CommonSendMsg(ctx, &forwarding.SendMsgReq{
		Sn:        req.Sn,
		ContextId: req.ContextId,
		Code:      code,
		Payload:   []byte(req.Payload),
		MsgType:   "property",
		Timeout:   req.Timeout,
	})
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}

	resp.Code = msg.Code
	resp.Msg = msg.Msg
	if msg.M != nil {
		resp.M = msg.M
	}
	return nil
}

func (the *ForwardingService) ServiceReply(ctx context.Context, req *pb.ForwardingServiceReplyReq, resp *pb.ForwardingServiceReplyResp) error {
	msg, err := forwarding.CommonSendMsg(ctx, &forwarding.SendMsgReq{
		Sn:        req.Sn,
		ContextId: "",
		Code:      req.Code,
		Payload:   []byte(req.Payload),
		MsgType:   "service_reply",
	})
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}

	resp.Code = msg.Code
	resp.Msg = msg.Msg
	return nil
}

func (the *ForwardingService) Watch(ctx context.Context, req *pb.ForwardingWatchReq, s *pb.ForwardingService_WatchServer) error {
	// 发送错误信息
	errMsg := &pb.ForwardingWatchResp{}
	defer func() {
		if errMsg.Code != 0 {
			err := s.Send(errMsg)
			if err != nil {
				logger.Infof("send msg fail:%s", err.Error())
			}
		}
	}()
	if len(req.Pks) > 0 && len(req.Sns) > 0 {
		errMsg.Code = errorsx.FAIL.Code
		errMsg.Msg = "不可同时指定产品标识跟设备标识"
		return nil
	}

	if len(req.Codes) > 0 && len(req.MsgTypes) > 1 {
		errMsg.Code = errorsx.FAIL.Code
		errMsg.Msg = "指定代码只能最多支持一种类型"
		return nil
	}

	return forwarding.Watch(ctx, req, s)
}

func (the *ForwardingService) PublishMsg(ctx context.Context, req *pb.ForwardingPublishMsgReq, resp *pb.ForwardingPublishMsgResp) error {
	common := make(map[string]any)
	err := json.Unmarshal([]byte(req.Payload), &common)
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = fmt.Sprintf("解析Payload出错 err:%s", err.Error())
		return nil
	}
	contextId := req.ContextId
	if contextId == "" {
		contextId = cast.ToString(common["context_id"])
	}
	common["id"] = utilsx.GenUuid()
	common["time"] = time.Now().UnixMilli()
	common["context_id"] = contextId

	if req.UseTopic {
		_, sn, group, msgType, code, isUp, err := client.DecodeMqttTopic(req.Topic)
		if err != nil {
			resp.Code = errorsx.FAIL.Code
			resp.Msg = fmt.Sprintf("解析topic出错 err:%s", err.Error())
			return nil
		}

		if isUp {
			resp.Code = errorsx.FAIL.Code
			resp.Msg = fmt.Sprintf("只能发送下行消息 topic:%s", req.Topic)
			return nil
		}

		if fmt.Sprintf("%d", utils.GetGroupId(sn)) != group {
			resp.Code = errorsx.FAIL.Code
			resp.Msg = fmt.Sprintf("分组跟设备不对应 sn:%s group:%s", sn, group)
			return nil
		}
		if sn != req.Sn {
			resp.Code = errorsx.FAIL.Code
			resp.Msg = fmt.Sprintf("主题sn不对应 sn:%s pagesn:%s", sn, req.Sn)
			return nil
		}

		req.Code = code
		req.Sn = sn
		req.ContextId = contextId
		req.MsgType = msgType
	}

	newbb, _ := json.Marshal(common)
	msg, err := forwarding.CommonSendMsg(ctx, &forwarding.SendMsgReq{
		Sn:        req.Sn,
		ContextId: req.ContextId,
		Code:      req.Code,
		Payload:   newbb,
		MsgType:   req.MsgType,
		Timeout:   req.Timeout,
	})
	if err != nil {
		resp.Code = errorsx.FAIL.Code
		resp.Msg = err.Error()
		return nil
	}

	resp.Code = msg.Code
	resp.Msg = msg.Msg
	return nil
}
